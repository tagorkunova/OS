1. ДОКАЗАТЕЛЬСТВО ОТСУТСТВИЯ ДЕДЛОКОВ

Дедлок возможен только когда:
- Два или более потока ждут друг друга
- Образуется циклическая зависимость захвата блокировок

Решение: через ПОРЯДОК ЗАХВАТА:

Блокировки ВСЕГДА захватываются в порядке от начала списка к концу.

Читающие потоки:
- Захватывают curr, затем next
- Освобождают curr, переходят на next
- Всегда движутся вперед по списку

Переставляющие потоки:
- Выбирают случайную позицию
- Идут к ней, блокируя узлы последовательно (с rdlock для rwlock)
- Захватывают три узла подряд: prev, curr, next ( именно в этом порядке)
- Освобождают в обратном порядке: next, curr, prev

Почему нет дедлоков:
- Поток A на позиции i захватывает узлы i-1, i, i+1
- Поток B на позиции j (j > i) захватывает узлы j-1, j, j+1
- Если i < j, то A захватит свои узлы раньше, чем B попытается захватить перекрывающиеся
- Циклической зависимости не возникает - порядок строго линейный

Специальный случай головы списка:
- Захват head_lock перед первым узлом
- Это самый "ранний" примитив, захватывается первым
- Читатели не трогают head_lock, только переставляющие при pos=0


2. ДОКАЗАТЕЛЬСТВО ОТСУТСТВИЯ RACE CONDITIONS

Race condition возникает когда:
- Несколько потоков обращаются к данным
- Хотя бы один пишет
- Нет правильной синхронизации

Защита:

а) Чтение данных узла:
   - Читающие потоки держат блокировку на curr и next
   - Проверяют curr->next == next (защита от перестановки)
   - Читают length только под блокировкой

б) Перестановка узлов:
   - Блокируем все три узла (prev, curr, next)
   - Проверяем связность (prev->next == curr && curr->next == next)
   - Только после проверки меняем указатели
   - Все изменения указателей атомарны относительно блокировок

в) Переход между узлами:
   - Hand-over-hand locking: захватываем next, потом освобождаем curr
   - В каждый момент держим хотя бы одну блокировку
   - Никто не может переставить узел, на котором мы находимся


3. РАЗНИЦА МЕЖДУ MUTEX И RWLOCK

Mutex (мутекс):
- Эксклюзивный доступ
- Один поток владеет - все остальные ждут
- Читатели и писатели равны - все блокируют всех

RWlock (read-write lock):
- Множественные читатели одновременно
- Писатель эксклюзивен
- Читатели не блокируют читателей

Почему rwlock быстрее при чтении:
1. Три читателя могут проходить по списку одновременно
2. Они блокируют друг друга только на одних узлах
3. С mutex каждый читатель блокировал бы весь узел

Писатели (swappers):
- В обеих версиях ждут друг друга одинаково
- Захватывают эксклюзивно
- Разница в том, что rwlock позволяет читателям работать пока нет писателя


4. ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ

Iterations (количество проходов):
- RWlock: больше итераций читателей
- Mutex: меньше итераций, больше ожидания

Swaps (количество перестановок):
- Похожие значения в обеих версиях
- Зависит от rand() и конкуренции

На практике:
- Spinlock: высокое CPU, много итераций на коротких списках
- Mutex: средние показатели, низкое CPU
- RWlock: больше итераций читателей на длинных списках


5. КОРРЕКТНОСТЬ ПЕРЕСТАНОВКИ

При перестановке curr и next:
- Меняем curr->next = next->next
- Меняем next->next = curr
- Меняем prev->next = next (или storage.first = next)

Требуется блокировка ТРЁХ узлов:
- prev: меняем prev->next
- curr: меняем curr->next, curr становится вторым
- next: меняем next->next, next становится первым

Без блокировки prev:
- Другой поток может переставить prev с кем-то
- prev->next будет указывать не туда
- Потеряем узлы или повредим список
